# 들어가면서          
> 외부 코드를 사용한다면 우리 코드에 맞게 깔끔하게 통합해야 한다.         
> 이같은 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴보자     

# 목차
[1. 외부 코드 사용하기](#외부-코드-사용하기)     
[2. 경계 살피고 익히기](#경계-살피고-익히기)     
[3. log4j 익히기](#log4j-익히기)     
[4. 학습 테스트는 공짜 이상이다.](#학습-테스트는-공짜-이상이다)   
[5. 아직 존재하지 않는 코드 사용하기](#아직-존재하지-않는-코드-사용하기)     
[6. 깨끗한 경계](#깨끗한-경계)     
 
# 외부 코드 사용하기       
> 경계 인터페이스를 직접적으로 사용하면 많은 문제가 발생한다.          

**패키지 제공자 / 프레임 워크 제공자 :**       
* 더 많은 환경에서 코드가 돌아가도록 적용성을 최대한 넓히려 애쓴다.  

**패키지 사용자 / 프레임 워크 사용자 :**       
* 자신의 요구에 집중하는 인터페이스(코드)를 원한다.   
   
이러한 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.   

## Map  
`Map`이 제공하는 기능성과 유연성은 유용하지만 그만큼 위험도 크다.     

* 필요하지 않은 기능 또한 제공     
  * `clear() 함수` :        
  Map 인스턴스를 직접적으로 만든 프로그래머는 필요한 로직이 아니면 사용하지 않겠지만             
  Map 인스턴스를 넘겨 받은 프로그래머는 언제든지 해당 메서드로 Map 값을 지울 수 있다.         

* 객체 유형에 제한이 없어 얼마든지 다른 객체 유형이 사용될 수 있다.    
  * `Sensor s = (Sensor) sesonrs.get(sensorId);`
  * Map 이 반환하는 Object를 올바른 유형으로 변환할 책임이 사용자에게 넘겨진다.  
  * 변환 코드를 작성하는 사람이 사용자이므로 코드간의 불일치 성을 초래할 수 있다.   
  * 또한 함수와 인자 사이에 어떤 관계가 있는지 함수 이름을 보고도 알기가 힘들다.  
  * 즉, 의도가 분명히 드러나지 않기 때문에 깨끗한 코드라 부르기 어렵다.         
          
* Map 인스턴스 사용중에 인터페이스가 변할 경우 ,수정할 코드가 많아진다.   
  * 실제로 자바5에서 제네릭을 도입했을때 Map 인터페이스가 변한적 있다.   
  * 이로인해 제네릭 사용을 금하는 시스템도 있다.   
  
### Map 개선한 코드  

```java
public class Sensors {
    private Map sensors = new HashMap();
    
    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }

}
```      
경계 인터페이스인 Map을 Wrapper 클래스 안으로 숨겼다.                         
즉, 기존에 Map 클래스를 사용했던 코드들을 Sensor 클래스로 대체했다.           
이같은 Wrapper 클래스를 사용하면 얻게 되는 장점들이 있다.           
          
**장점**            
* 사용자는 Map에 제네릭스가 사용되었는지 여부에 신경 쓸 필요가 없어졌다.            
* Map 인터페이스가 변하더라도 Wrapper 객체를 사용하기에 다른 프로그램에는 영향을 미치지 않는다.          
* 프로그램에 필요한 인터페이스만 제공할 수 있다. 
* 필요한 인터페이스를 사용하는 과정에서 보다 명확한 이름을 지정해줄 수 있다.      
* Wrapper 클래스는 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.      
  
하지만, Map 클래스를 사용할 때마다 캡슐화하라는 소리는 아니다.      
Map과 같은 경계 인터페이스를 여기저기 넘기지 말라는 말이다.   
Map과 같은 경계 인터페이스를 사용할때는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의해야한다.   
Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 말자.   
사용해야 한다면 위와 같이 캡슐화하여 사용하는 방법을 채택하자   
           
# 경계 살피고 익히기     
> 외부 코드를 사용하면 적은 시간에 더 많은 기능을 출시하기 쉬워진다.      
> 만약 외부에서 가져온 패키지를 사용하고 싶다면 어디서 어떻게 시작할까?           
          
**외부 패키지 사용에 앞서 테스트를 진행하자**            
외부 패키지에 대한 테스트는 우리의 책임은 아니다.            
하지만 우리 자신을 위해 **우리가 사용할 외부 코드를 미리 테스트하는 편은 바람직하다.**              
예를 들어 타사 라이브러리를 우리 코드에 적용시켜 테스트를 동작을 확인했는데           
버그가 발생하면 우리 코드 문제인지 외부 라이브러리 문제인지 오랜 디버깅을 통해서 알 수 있다.   
    
외부 코드를 익히기는 어렵다.       
외부 코드를 통합하기도 어렵다.        
2가지를 동시에 하기는 두 배나 어렵다.   
그렇다면 다르게 접근하는 것은 어떨까?    
          
우리쪽 코드를 작성해 외부 코드를 호출하는 대신          
먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까?      
즉, 사용에 앞서 외부 코드에 대한 학습을 테스트로 진행하는 것이다.   
그리고 이를 **학습 테스트**라고 부른다.   
   
학습 테스트는 프로그램에서 사용허려눈 방식대로 외부 API를 호출한다.        
통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.        
학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.       
 
# log4j 익히기    
로깅 기능을 직접 구현하는 대신 log4j 패키지를 사용한다고 가정하자      
패키지를 내려받아 소개 페이지를 연다. (document)         
문서를 자세히 읽기 전에 테스트 케이스를 작성한다.       
화면에 `"hello"`를 출력하는 테스트 케이스다.       

```java
@Test
pubilc void testLogCreate() {
    Logger logger = Logger.getLogger("MyLogger");
    logger.info("hello");
}
```






 


   




# log4j 익히기   
# 학습 테스트는 공짜 이상이다  
# 아직 존재하지 않는 코드 사용하기 
# 깨끗한 경계 
# 마치며 
