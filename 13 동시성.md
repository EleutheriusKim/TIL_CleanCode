# 🛠 현재 작성중....

# 들어가면서 
> 객체는 **처리의 추상화**다.     
> 스레드는 **일정의 추상화**다.         
         
**동시성(Concurrent)과 깔끔한 코드는 양립하기 어렵다.**            
단일 스레드에서 동작하는 코드를 작성하기는 쉽지만       
멀티 스레드로 코드를 작성하는 것은 문제를 발생시킬 가능성이 높기에 어렵다.      
         
이 장에서는       
* 여러 스레드를 동시에 돌리는 이유를 논한다.        
* 여러 스레드를 동시에 돌리는 어려움도 논한다.          
* 이런 어려움에 대처하고 깨끗한 코드를 작성하는 방법도 몇 가지 제안한다.     
* 마지막으로, 동시성 테스트하는 방법과 문제점을 논한다.        
   
# 동시성이 필요한 이유?   
동시성은 **결합을 없애는 전략**으로 **`무엇`과 `언제`을 분리하는 전략**이다.        
   
**무엇 :** 무엇을 할 것인가.   
**언제 :** 언제까지 할 것인가.    
     
**스레드가 하나인 프로그램은 `무엇`과 `언제`가 서로 밀접하다.**                
그래서 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.            
예를 들면, 디버깅할 때 정지점을 정하고 어느 지점에 걸렸는지 파악할 수 있다.          
             
**`무엇`과 `언제`** 를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.             
프로그램은 거대한 루프 하나가 아닌, 작은 협력 프로그램 여럿으로 보여진다.              
그렇기에 시스템을 이해하기가 쉽고, 문제를 분리하기도 쉽다.         
   
**필자가 이해한 내용**   
```
하나로 결홥된 무엇과 언제는, 둘 중 하나라도 값이 바뀌면 재사용하기 힘들어진다.  
예를 들면, 똑같은 작업을 하지만 제한시간이 다른 경우,       
제한시간이 똑같지만, 해야하는 작업이 다른 경우 새로운 코드를 작성해한다.    
          
그렇기에 하나로 결합된 무엇과 언제를 분리하여      
필요한 요소들을 제각기 조합하듯이 재사용하도록 분리하자      
```   
              
예를 들면, 서블릿은 웹 혹은 EJB컨테이너 안에서 돌아가는데,              
이들 컨테이너는 동시성을 **부분적으로 관리한다.**           
                
1. 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다.          
2. 각 서블릿 스레드는 **다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.**         
3. 이로인해, 서블릿 프로그래머는 들어오는 모든 웹 요청에 대해 관리할 필요가 없어졌다.      
                  
사실, 웹 컨테이너가 제공하는 `결합 분리 전략`** 은 완벽과 거리가 멀다.                
그럼에도 서블릿 모델이 제공하는 **구조적 이점이 크기 때문에 사용하는 것이다.**        
                   
구조적 개선만을 위해 동시성을 채택하는 건 아니다.                         
**응답 시간과 작업 처리량 개선**이라는 요구사항으로 인해 동시성을 사용하는 경우도 있다.      
       
예를 들면, 웹 크롤링 시스템이 단일 쓰레드라면 하나의 사이트의 데이터만 수집 가능하다.      
더군다나 사이트의 갯수가 늘어난다면, 기존보다 시간이 더 오래걸리는 문제가 발생한다.          
그렇기에 이 같은 경우, 다중 스레드 알고리즘을 이용해서 시스템의 성능을 높일 수 있다.   
 
## 미신과 오해 
동시성이 반드시 필요한 상황은 존재하지만, **동시성은 어렵다.**    
각별히 주의하지 않으면 난감한 상황에 처한다.      
    
아래에는 **동시성과 관련한 일반적인 미신과 오해**에 대해 기술했다.   
 
* 동시성은 항상 성능을 높여준다? :     
    동시성은 **때로** 성능을 높여준다.     
    대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나,     
    여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높여진다.     
    어느 쪽도 일반적으로 발생하는 상황은 아니기에, **때론 성능을 높여준다고 말한다.**    
* 









# 난관 


   






   
   
