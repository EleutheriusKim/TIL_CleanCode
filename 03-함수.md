# 들어가면서   
 > 함수는 어떤 프로그램이든 가장 기본적인 단위가 된다.       
[1. 작게 만들어라!](#작게-만들어라!)     

# 작게 만들어라! 
* 함수를 만드는 첫째 규칙은 **'작게!'**다.      
* 함수를 만드는 둘째 규칙은 **'더 작게!'**다.    
* 이렇게 작게 만든 함수들은 각 함수마다 명백하게 하나의 이야기를 표현할 수 있으며 그렇게 해야 한다.        
     
우리는 아래같은 코드를 3분만에 해석할 수 있을까?   
    
**나쁜 코드**
```java
    public static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {
        Wikipage wikipage = pageData.getWikiPage();
        StringBuffer buffer = new StringBuffer();
        if (pageData.hasAttribute("Test")) {
            if (includeSuiteSetup) {
                WikiPage suiteSetup = PageCrawlerlmpl.getlnheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);
                if (suiteSetup != null) {
                    wikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);
                    String pagePathName = PathParser.render(pagePath);
                    buffer.append("include -setup .").append(pagePathName).append("\n");
                }
            }
            WikiPage setup = PageCrawlerlmpl.getInheritedPage("SetUp", wikiPage);
            if (setup != null) {
                WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);
                String setupPathName = PathParser.render(setupPath);
                buffer.append("!include -setup .").append(setupPathName).append("\n");
            }
        }
        buffer.append(pageData.getContent());
        if (pageData.hasAttribute("Test")) {
            WikiPage teardown = pageCrawlerlmpl.getInheritedPage("TearDown", wikiPage);
            if (teardown != null) {
                WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);
                String tearDownPathName = PathParser.render(tearDownPath);
                buffer.append("\n").append("!include -teardown .").append(tearDownPathName).append("\n");
            }
            if (includeSuiteSetup) {
                WikiPage suiteTeardown = PageCrawlerlmpl.getlnheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);
                if (suiteTeardown != null) {
                    Wikipagepath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);
                    String pagePathName = PathParser.render(pagePath);
                    buffer.append("!include -teardown .").append(pagePathName).append("\n");
                }
            }
        }
        pageData.setContent(buffer.toString());
        return pageData.getHtml();
    }

```
* 위 코드는 추상화 수준도 너무 다양하고, 코드도 너무 길다.   
   * 두 겹으로 중첩된 if문은 이상한 플래그를 확인하고, 이상한 문자열을 사용하며, 이상한 함수를 호출한다.   

☑︎ 추상화 수준이란? 
```
말 그대로 구체적으로 풀어 쓰기보다는 추상적으로 표현되어 있다면 추상화 수준이 높은 것이고, 
추상화 되어 있지 않고 직접적인 코드는 추상화 수준이 낮다고 한다.

// (출처: https://starkying.tistory.com/entry/clean-code-functions)
```
     
**개선 코드**
```java
    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
        boolean isTestPage = pageData.hasAttribute("Test");
        if (isTestPage) {
            WikiPage testPage = pageData.getWikiPage();
            StringBuffer newpageContent = new StringBuffer();
            includeSetupPages(testPage, newPageContent, isSuite);
            newPageContent.append(pageData.getContent());
            includeTeardownPages(testPage， newPageContent, isSuite); pageData.setContent(newPageContent.toString());
        } return pageData.getHtml();
    }
```
* 중복된 코드들을 찾아서 메서드 몇 개를 추출하고, 이름 몇 개를 변경하고, 구조를 조금 변경했더니 코드를 매우 간략히 표현할 수 있었다.
     
**더 개선 코드**
```java
    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
        if (isTestPage(pageData)) {
            includedSetupAndTreadownPages(pageData, isSuite);
        } return pageData.getHtml();
    }
```
* 해당 메서드내의 로직을 조금 더 맥락에 맞춰 분할하니 위와 같이 코드 길이가 줄었으며 가독성이 좋아졌다.     
     
# 블록과 들여쓰기   
* `if 문, else 문, while 문` 등에 들어가는 블록은 한 줄이어야 한다는 의미입니다.   
   * 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워집니다.       
* 중첨 구조가 생기는 만큼 함수가 커져서는 안 된다는 뜻이기도 합니다.              
* **그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.**   
   * 당연한 말이지만 그래야 함수는 읽고 이해하기 쉬워야 하기 때문입니다.
      
# 한 가지만 해라        
### **함수를 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**     
   * 문제라면 그 '한 가지'가 무엇인지 알기가 어렵다는 점이다.
   
```java
    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
        if (isTestPage(pageData)) {
            includedSetupAndTreadownPages(pageData, isSuite);
        } return pageData.getHtml();
    }
```   
코드를 살펴보자   

* 페이지가 테스트 페이지인지 판단한다.   
* 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다
* 페이지를 HTML로 렌더링 한다.   
      
위 같은 경우 한 가지 일을 한다고 말할 수 있을까?       
아니면 3가지 일을 한다고 말할 수 있을까?          
위에서 언급한 3단계는 지정된 함수 이름 아래에서 **추상화 수준이 하나이다**    
       
함수를 간단한 TO 문단으로 기술할 수 있다.   

**추상화 수준이 1단계임을 보여주는 TO 문단**
```
TO renderPageWithSetupsAndTeardowns,   
페이지가 테스트 페이인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다.   
테스트 페이지든 아니든 페이지를 HTML로 렌더링 한다.   
```
지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.      
  
함수가 '한 가지'만 하는지 판단하는 방법이 하나 더 있다.      
단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.      

**함수 내 섹션**        
예를 들어 함수내에서 Declaration, Initializations, sieve 라는 개념의 섹션이 있고      
메서드 형태가 아닌 일반 코드라면 이는 한 함수에서 여러 작업을 한다는 뜻이다.     
한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.     
  
## 함수 당 추상화 수준은 하나로!   
함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다.        
만약 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.       
특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다.      
하지만 문제는 이 정도로 그치지 않는다.     
근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.      
   
**위에서 아래로 코드 읽기 : 내려가기 규칙**   
코드는 위에서 아래로 이야기처럼 읽혀야 좋다.         
한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.         
         
**즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.**          
다르게 표현하자면, 일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다는 의미다.     

```
TO 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.   
   TO 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다.   
   TO 슈트 설정 페이지를 포함하려면 부모 계층에서 SuiteSetUp 페이지를 찾아 include 문과 페이지 경로를 추가한다.   
   TO 부모 계층을 검색하려면..   
```
  
하지만 추상화 수준이 하나인 함수를 구현하기란 쉽지 않다. **핵심은 짧으면서도 '한 가지'만 하는 함수다.**          
위에서 아래로 TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기가 쉬어진다.      

## Switch문
* 본질적으로 'Switch' 문법은 N가지를 처리하기에 코드가 길 수 밖에없다.   
* 각 'Switch' 문법을 **저차원 클래스에 숨기고 절대로 반복하지 않는 방법이 있다.(물론 다형성을 이용한다.)**

```java
    public Money calculatePay(Employee e) throws InvalidEmployeeType{
        switch (e.type){
            case COMMISSIONED: 
                return calculateCommissionedPay(e);
            case HOURLY:
                return calculateHourlyPay(e);
            case SALARIED:
                return calculateSalariedPay(e);
            default:
                throw new InvalidEmployeeType(e.type);
        }
    }
```
하지만 위 함수에는 문제가 있습니다.          
1. 함수가 길다. (새 직원 유형 Enum 타입을 추가하면 코드가 길어집니다.)       
2. '한 가지 작업'만 수행하지 않습니다.       
3. 'SRP'를 위반합니다. (코드를 변경할 이유가 여럿 있기 때문입니다.)            
4. OCP(Open Closed Principal)를 위반합니다. (새 직원 유형을 추가할 때마다 코드를 변경하기 때문입니다.)      
5. 가장 심각한 문제라면 위 함수와 구조가 동일한 함수가 무한정 존재한다는 사실입니다.   


