# 들어가면서 
> 뭔가 잘못될 가능성은 늘 존재한다.    
> **뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있다.**      

깨끗한 코드와 오류 처리는 확실히 연관성이 있다.       
상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다.  
오류 처리는 중요하다.    
하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면    
깨끗한 코드라 부르기 어렵다.   

이제부터 우리는 **우아하고 고상하게** 오류를 처리하는 기법을 배워보겠다.   

# 오류 코드보다 예외를 사용하라      

```java
public class DeviceController {
    ...
	  public void sendShutDown() {
		    DeviceHandle handle = getHandle(DEV1);
		    // 디바이스 상태를 점검한댜.
		    if (handle != DeviceHandle.INVALID) {
			  // 레코드 필드에 디바이스 상태를 저장한다.
			      retrieveDeviceRecord(handle);
			      // 디바이스가 일시정지 상태가 아니라면 종료한다.
			      if (record.getStatus() != DEVICE_SUSPENDED) {
				        pauseDevice(handle);
				        clearDeviceWorkQueue(handle);
				        closeDevice(handle);
			      } else {
                logger.log("Device suspended. Unable to shut down");
			      }
		    } else {
			      logger.log("Invalid handle for: " + DEV1.toString());
		    }
	  }
	  ...
}
```
오류 코드를 사용한다면 몇가지 문제점이 발생한다.      
   
* 함수를 호출한 즉시 오류를 확인해야 하기 때문에 호출자 코드가 복잡해진다.      
* 오류 확인을 잊어버리기 쉽다.
     
```java
public class DeviceController {
	  ...
	  public void sendShutDown() {
		    try {
			      tryToShutDown();
		    } catch (DeviceShutDownError e) {
			      logger.log(e);
		    }
	  }

	  private void tryToShutDown() throws DeviceShutDownError {
		    DeviceHandle handle = getHandle(DEV1);
		    DeviceRecord record = retrieveDeviceRecord(handle);
		    pauseDevice(handle); 
		    clearDeviceWorkQueue(handle); 
		    closeDevice(handle);
	  }

	  private DeviceHandle getHandle(DeviceID id) {
		    ...
		    throw new DeviceShutDownError("Invalid handle for: " + id.toString());
		    ...
	  }
	  ...
}
```
예외를 던지는 방법은 호출자 코드를 깔끔하게 만들어 논리가 뒤섞이지 않게 해준다.      

* 가독성이 좋아졌다.  
* 코드 품질이 나아졌다.   
* 기능 알고리즘과 오류 처리 알고리즘을 분리했다.   
* 각 개념을 독립적으로 살펴보고 이해할 수 있게 되었다.   

# Try-Catch-Finally 문부터 작성하라    
> 프로그램 안에다 **범위를 지정한다**는 사실은 매우 흥미롭다.    
     
`try 블록`은 어떤 면에서 트랜잭션과 비슷하다.              
`try 블록`에서 무슨 일이 생기든지 `catch 블록`은 프로그램 상태를 일관성 있게 유지하기 때문이다.           
그러므로 코드를 짤때는 **`try-catch-finally 문`** 으로 시작하는 편이 낫다.      
그러면 `try 블록`에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다.   
즉, 예외 처리를 지정함으로써 프로그래머는 코드의 방향성을 생각하면서 코드를 짤 수 있다.   

## 테스트를 이용한 예시
### 1. 단위 테스트 작성   
```java
@Test(expected = StorageException.class)
public void retrieveSectionShouldThrowOnInvalidFileName() {
    sectionStore.retrieveSection("invalid - file");
}
```
* 파일이 없으면 예외를 던지는지 알아본다.  

### 2. 실제 코드 구현 
```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    // 실제로 구현할 때까지 비어 있는 더미를 반환한다.
    return new ArrayList<RecordedGrip>();
}
```
* 실제로 구현할 때까지 비어 있는 더미를 반환한다.   
* 하지만 위 코드는 예외를 던지지 않으므로 단위 테스트는 실패한다.   

### 3. 실제 코드 구현 - 예외 상황 추가   
잘못된 파일 접근을 시도하게 구현을 변경해보았다.   
     
```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream stream = new FileInputStream(sectionName);
	stream.close();
    } catch (Exception e) {
        throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
}
```
* 파일을 읽어들이는 코드를 작성했고 예외가 발생하게끔 만들었다.   
* 이 시점에서 해당 코드는 리팩토링이 가능하다.
     
```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream stream = new FileInputStream(sectionName);
	stream.close();
    } catch (FileInputException e) {
        throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
}
```
* catch 블록에서 예외 유형을 좁혀 FileInputStream 생성자가 던지는 FileInputException을 잡아낸다.

### 4. 실제 코드 수현 - 논리 추가 
`try-catch` 구조로 범위를 정의했으므로 TDD를 사용해 필요한 나머지 논리를 추가한다.    
    
```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream stream = new FileInputStream(sectionName);
	... 	// 추가 로직 
	... 	// 추가 로직
	... 	// 추가 로직 
	stream.close();
    } catch (FileInputException e) {
        throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
}
```
* 나머지 논리는 `FileInputStream` 생성 코드와 `stream.close()` 사이에 작성한다.   
* 오류나 예외가 전혀 발생하지 않는다고 가정한다.   
   
이후, 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하자        
그러면 자연스럽게 `try 블록`의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.    
쉽게 얘기하면 트랜잭션 처럼 한 기능을 온전히 수행하는 범위를 인위적으로 만들었다 볼 수 있다.     
   
# 미확인(unchecked) 예외를 사용하라      
> 여러 해 동안 자바 프로그래머들은 **확인된(checked) 예외**의 장단점을 놓고 논쟁을 벌여왔다.          
> 하지만 지금은 안정적인 소프트웨어를 제작하는 요소로 반드시 필요하지 않다는 사실이 분명해졌다.    
  
```java
public void catchFileInputException() {
    try { 
        a();
    } catch (FileInputException e) {
        throw new StorageException("retrieval error", e);
    }
}

public void a() throws FileInputException { 
    aa(); 
}

public void aa() throws FileInputException {
    aaa();
}

public void aaa() throws FileInputException {
    FileInputStream stream = new FileInputStream(sectionName);
    stream.close();
}
```
* 확인된 예외는 OCP를 위반한다.   
* 메서드에서 예외를 던졌는데 catch 블록이 3단계 위에 있다면 모든 선언부에 예외를 정의해야한다.   
* 즉, 하위 단계에서 코드를 수정하면 모든 상위 단계 메서드 선언부를 고쳐야한다.       
* 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 선언부가 바뀌었으므로 모듈을 다시 빌드 후 배포 해야한다.
    
대규모의 시스템에 호출이 일어나는 방식을 살펴보자      
최상위 함수가 아래 함수를 호출하고 아래 함수는 더 아래 함수를 호출한다.      
만약 최하위 함수에서 기존과 다른 `chekced 예외`가 발생한다면? 아래와 같은 동작을 취해야 한다.     
  
1. `catch 블록`을 가진 상위 메서드에 새로운 예외 처리를 추가한다.   
2. 연관된 메서드의 선언부에 새로운 예외를 추가해줘야 한다.     
       
결과적으로 최하단부터 최상단까지 연쇄 작용이 일어나고        
throws 경로에 위치하는 모든 함수는 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.       
  
때로는 확인된 예외도 유용하다.      
아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 한다.     
하지만 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크므로 미확인 예외를 사용하는 것이 좋다.   

## 번외 - 미확인(unchecked) 예외란?      



# 예외에 의미를 제공하라      
# 호출자를 고려해 예외 클래스를 정의하라   



