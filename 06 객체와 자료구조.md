# 들어가면서    
> 어째서 수많은 프로그래머가 조회(getter)함수와 설정(setter)함수를 당연하게 공개(public)해 비공개 변수를 외부에 노출시킬까?      
   
# 자료 추상화 

```java
pulblic class Point {
    public double x;
    public double y;
}
```
* 직교좌표계를 사용한다.        
* 개별적으로 좌표값을 읽고 설정하게 강제한다.      
* 변수를 `private`로 설정하더라도 각 값마다 조회 함수와 설정 함수를 제공한다면 구현을 외부로 노출한다.      
  * getter
  * setter
     
```java
public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);   
}
```
* 인터페이스에서는 직교좌표계를 사용하는지 극좌표계를 사용하는지 알 수는 없지만 자료구조를 명백하게 표현한다.   
* 사실 인터페이스는 자료구조 그 이상을 표현하며 클래스 메서드가 접근 정책을 강제한다.   
  * 좌표를 읽을 때는 각 값을 개별적으로 읽어야한다.   
  * 좌표를 설정 할 때는 두 값을 한번에 설정해야 한다.  
   
변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다.   
구현을 감추려면 **추상화가 필요하다!**      
조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되지는 않는다.     
그보다는 추상 인터페이스를 제공해 **사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야** 진정한 의미의 클래스이다.      

```java
public interface Vehicle {
    double gotFuelTankCapacityInGallons();
    double getGallonsOfFasoline();
}
```
* 자동차 연료 상태를 구체적인 숫자 개념으로 알려준다.   

```java
public interface Vehicle {
    double getPercentFuelRemainning();
}
```
* 자동차 연료 상태를 백분율이라는 추상화된 개념으로 알려준다.   
      
위 코드보다 아래 코드들이 더 좋다.      
자료를 세세샇게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.         
인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지않는다.           
개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.       
**아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁜 것이다.**    

# 자료/객체 비대칭 
> **객체 :**  추상화 뒤로 자룔를 숨긴 채 자료를 다루는 함수만 공개한다.      
> **자료구조 :** 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.         
   
**절차적인 도형**   
```java
public class Square { 
	public Point topLeft; 
	public double side;
}

public class Rectangle { 
	public Point topLeft; 
	public double height; 
	public double width;
}

public class Circle { 
	public Point center; 
	public double radius;
}

public class Geometry {
	public final double PI = 3.141592653589793;

	public double area(Object shape) throws NoSuchShapeException {
		if (shape instanceof Square) { 
			Square s = (Square)shape; 
			return s.side * s.side;
		} else if (shape instanceof Rectangle) { 
			Rectangle r = (Rectangle)shape; 
			return r.height * r.width;
		} else if (shape instanceof Circle) {
			Circle c = (Circle)shape;
			return PI * c.radius * c.radius; 
		}
		throw new NoSuchShapeException(); 
	}
}
```
* 각 도형 클래스는 간단한 자료구조다
  * 즉, 아무 메서드도 제공하지 않는다.   
  * 도형이 동작하는 방식은 Geometry에서 클래스에서 구현한다.   

위 코드는 객체 지향적인 코드라 말하기는 어렵지만 완전 아니지는 않다.   
* 함수를 추가할 때는 도형 클래스는 수정할 필요가 없다.
* 도형을 추가할 때는 모든 함수를 수정해야 한다.

**다형적인 도형(객체 지향)**
```java
public class Square implements Shape { 
	private Point topLeft;
	private double side;

	public double area() { 
		return side * side;
	} 
}

public class Rectangle implements Shape { 
	private Point topLeft;
	private double height;
	private double width;

	public double area() { 
		return height * width;
	} 
}

public class Circle implements Shape { 
	private Point center;
	private double radius;
	public final double PI = 3.141592653589793;

	public double area() {
		return PI * radius * radius;
	} 
}
```



# 형식을 맞추는 목적    
> **'돌아가는 코드'** 는 시간이 지나면 언제든지 바뀔 가능성이 있다.   
> **'코드의 가독성'** 은 시간이 지나더라도 유지보수 용이성과 확정성에 계속 영향을 미친다.  
     
오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도    
맨 처음 잡아놓은 구현 스타일과 가독성 수준은 시간이 지나더라도 유지보수 용이성과 확정성에 계속 영향을 미친다.   
원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다는 점을 명시하자        

# 적절한 행 길이를 유지하라   
## 신문 기사처럼 작성하라     
> 소스 파일도 신문 기사와 비슷하게 작성한다.     
      
이름은 간단하면서도 설명이 가능하게 짓는다.     
이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경써서 짓는다.      
     
* 소스파일 첫 부분 : 고차원 개념과 알고리즘 설명      
* 소스파일 중간 부분 : 내려갈 수록 의도를 세세하게 묘사   
* 소스파일 마지막 부분 : 가장 저차원 함수와 세부 내역      

```
신문은 다양한 기사로 이루어진다.  
대다수의 기사가 짧으며 한 면을 채우는 기사는 거의 없다.   
내용, 날짜 ,이름 등을 무작위로 뒤섞은 긴 기사 하나만 싣는다면 아무도 읽지 않으리라.
```

## 개념은 빈 행으로 분리하라
> 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다.  
   
* 그렇기에 생각 사이는 빈 행을 넣어 분리해야 마땅하다.   

```java
package SingleTone;

public class Settings {
    private static class SettingsHolder {
        public static final Settings settings = new Settings();
    }
    private Settings() { }
    public static Settings getInstance() { return SettingsHolder.settings; }
    private boolean darkMode = false; // default false
    private int fontSize = 13; // default 13
    public  boolean getDarkMode(){return darkMode;}
    public int getFontSize(){return fontSize;}
    public void setDarkMode(boolean _darkMode){darkMode = _darkMode;}
    public void setFontSize(int _fontSize){fontSize = _fontSize;}

}
```

```java
package SingleTone;

public class Settings {

    private static class SettingsHolder {
        public static final Settings settings = new Settings();
    }

    private Settings() { }
    
    public static Settings getInstance() { return SettingsHolder.settings; }

    private boolean darkMode = false; // default false
    private int fontSize = 13; // default 13

    public  boolean getDarkMode(){return darkMode;}
    public int getFontSize(){return fontSize;}
    public void setDarkMode(boolean _darkMode){darkMode = _darkMode;}
    public void setFontSize(int _fontSize){fontSize = _fontSize;}

}
```

## 수직거리 
> 서로 밀접한 개념은 세로로 가까이 두어야 한다.         
     
* 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표시한다.  
* 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스파일과 클래스를 여기저기 뒤지게 된다.  
  * 연관성 : 한 개념을 이해하는데 다른 개념이 중요한 정도
  * 연관성이 높은 데 서로 다른 파일에 존재하면 안된다. (protected 변수를 사용 안하는 이유)
      
**변수 선언**  
* 변수는 사용하는 위치에 최대한 가까이 선언한다.   
* 루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다.    
* 아주 드물지만 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다.    

```java
public void method(){
  InputStream is = null;
  try {
    is = new FileInputStream(getPreferncesFile());
    ...
  } catch {
    ...
  }
}
```

```java
public int countTestCases() {
   int count = 0;
   for (Test each : tests)
     count += each.countTestCases();
   return count;  
}
```

```java
for (xmlTest test : m_suite.getTests()) {
  TestRunner tr = m_runnerFactory.newTestRunner(this, test);
  ...
  ...
}
```

**인스턴스 변수 선언**    
* 클래스 맨 처음에 선언한다.
* 변수 간에 세로로 거리를 두지 않는다.   
* 잘 설계한 클래스는 대다수의 메서드가 인스턴스 변수를 사용하기 때문이다.   

```java
public class SessionUser implements Serializable {
    private String userId;
    private String userName;
    private String userNickname;
    private Role userRole;

    public SessionUser(User user) {
            this.userId = user.getUserId();
            this.userName = user.getName();
            this.userNickname = user.getNickName();
            this.userRole = user.getRole();
    }

    public boolean checkAdmin(){
        return userRole.getKey().equals("ADMIN");
    }
}
```

**종속 함수**   
* 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.   
* 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.   
* 규칙을 일관적으로 적용한다면 독자는 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측한다.    
  * 그러면 프로그램이 자연스럽게 읽힌다.   

```java
public class WikiPageResponder implements SecureResponder {
  protected WikiPage page;
  protected PageData pageData;
  protected String pageTitle;
  protected Request request;
  protected PageCrawler crawler;

  public Response makeResponse(FitNesseContext context, Request request) throws Exception {
    String pageName = getPageNameOrDefault(request, "FrontPage");
    loadPage(pageName, context);
    if (page == null)
      return notFoundResponse(context, request);
    else
      return makePageResponse(context);
  }

  private String getPageNameOrDefault(Request request, String defaultPageName) {
    String pageName = request.getResource();
    if (StringUtil.isBlank(pageName))
      pageName = defaultPageName;

    return pageName;
  }

  protected void loadPage(String resource, FitNesseContext context) throws Exception {
    WikiPagePath path = PathParser.parse(resource);
    crawler = context.root.getPageCrawler();
    crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler());
    page = crawler.getPage(context.root, path);
    if (page != null)
      pageData = page.getData();
  }

  private Response notFoundResponse(FitNesseContext context, Request request) throws Exception {
    if (dontCreateNonExistentPage(request))
      return new NotFoundResponder().makeResponse(context, request);
    return new EditResponder().makeResponseForNonExistentPage(context, request);
  }

  private boolean dontCreateNonExistentPage(Request request) {
    String dontCreate = (String) request.getInput("dontCreatePage");
    return dontCreate != null && (dontCreate.length() == 0 || Boolean.parseBoolean(dontCreate));
  }

  private SimpleResponse makePageResponse(FitNesseContext context) throws Exception {
    pageTitle = PathParser.render(crawler.getFullPath(page));
    String html = makeHtml(context);

    SimpleResponse response = new SimpleResponse();
    response.setMaxAge(0);
    response.setContent(html);
    return response;
  }
  ...
}
```

**개념적 유사성**   
* 개념적인 친화도가 높아 서로를 끌어 당기는 코드는 가까이에 배치한다.   
  * 함수가 다른 함수를 호출하면서 생기는 직접적인 종속성      
  * 변수와 해당 변수를 사용하는 함수와의 종속성   
  * **비슷한 동작을 수행하는 일군의 함수**    

```java
public class Assert {

    static public void assertTrue(String message, boolean condition) {
        if (!condition) {
            fail(message);
        }
    }

    static public void assertTrue(boolean condition) {
        assertTrue(null, condition);
    }

    static public void assertFalse(String message, boolean condition) {
        assertTrue(message, !condition);
    }

    static public void assertFalse(boolean condition) {
        assertFalse(null, condition);
    }
    
    ....
```
* 위 함수들은 명명법이 똑같고 기본 기능이 유사하고 간단하여 친화도가 매우 높다.   
* 종속적인 관계가 없더라도 가까이 배치할 함수들이다.  

**세로 방향**   
* 함수 호출 종속성은 아래 방향으로 유지한다.   
* 호출하는 함수 다음에 호출되는 함수를 배치한다.   
* **그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.(세부적으로)**   
* 신문 기사도 마찬가지
  * 제목
  * 주제
  * 세부 내용
* 소스 파일에서 첫 함수 몇 개만 읽어도 개념을 파악하기 쉬워진다.   

# 가로 형식 맞추기   
> 프로그래머는 명백하게 짧은 행을 선호한다.   
   
## 가로 공백과 밀집도   
> 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.      

```java
private void measureLine(String line) {
  lineCount++;
  int lineSize = line.length();
  lineWidthHistogram.addLine(lineSize, lineCount);
  double result = (-b - Math.sqrt(determinant)) / (2*a);

}
```
* 할당 연산자 : `int lineSize = line.length();`
  * 할당 연산자를 강조하려고 앞뒤에 공백을 주었다.
  * 공백을 넣으면 2가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다.  
* 메서드 : `lineWidthHistogram.addLine(lineSize, lineCount);`
  * 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다.   
  * 함수와 인수는 서로 밀접하기 때문이다. (오히려 공백을 넣으면 분리되어 보인다.)   
  * 대신, 각 인수는 서로 별개이기 때문에 쉼표 뒤에 공백을 넣어 준다. `(인수1, 인수2)`   
* 연산자 우선순위 :  
  * 승수 사이에는 공백이 없다 : 곱셈은 우선순위가 가장 높기 때문이다.      
  * 항 사이에는 공백이 들어간다 : 덧셈과 뺄샘은 우선순위가 곱셈보다 낮기 때문이다.    
  * 불행히도 코드 형식을 자동으로 맞춰주는 도구는 대다수가 연산자 우선 순위를 고려하지 못해 해쳐지는 경우가 많다.  
    
## 가로 정렬     
특정 구조를 가종하고자 가로 정렬을 이용하면 아래와 같은 코드가 된다.   
```java
public class FitNesseExpediter implements ResponseSender 
{
   private  Socket         socket;
   private  InputStream    input;
   private  OutPutStream   output;
   ...
   
   public FitNesseExpediter(Socket           s, 
                            FitNesseContext  context) throws Exception
   {
      socket   =     s;
      input    =     s.getInputStream();
      output   =     s.getOutputStream();
   }
}
```
언뜻 유용하고 가독성이 좋은 것 같지만 사실을 그러지 않다.   

* 변수 유형은 무시하고 변수 이름부터 읽게 된다.   
* 할당 연산자는 보이지 않고 오른쪽 피연산자에 눈이 간다.   
* 설상가상으로 코드 형식을 자동으로 맞춰주는 도구는 대다수가 위와 같은 정렬을 무시한다. (해친다)      

```java
public class FitNesseExpediter implements ResponseSender 
{
   private Socket socket;
   private InputStream input;
   private OutPutStream output;
   ...
   
   public FitNesseExpediter(Socket s, FitNesseContext  context) throws Exception
   {
      socket = s;
      input = s.getInputStream();
      output = s.getOutputStream();
   }
}
```
* 정렬을 하지 않으면 오히려 중대한 결함을 찾아내기 쉽다.   
  * 필자 개인적인 생각으로 위 같은 코드가 가독성이 좋다.   
* **정렬이 필요한 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 아니다.**   

## 들여 쓰기     
> 소스 파일은 윤곽도와 계층이 비슷하다.                
> 계층에서 각 수준은 이름을 선언하는 범위이자 선언문과 실행문을 해석하는 범위이다.          
     
**범위(scope)로 이루어진 계층을 표현하기 위해 우리는 코드를 들여쓴다.**        
계층에서 코드가 자리잡은 수준에 비례한다. (클래스 정의처럼 파일 수준인 문장은 들여쓰지 않는다.)   
   
프로그래머는 들여쓰기 체계에 크게 의존한다.     
왼쪽으로 코드를 맞춰 코드가 속하는 범위를 시각적으로 표현한다.     
그러면 이 범위에서 저 범위로 재빨리 이동하기 쉬워진다.      

```java
public class FirstPage { private Settings settings = Settings.getInstance(); 
public void setAndPrintSettings() { settings.setDarkMode(true); settings.setFontSize(15); 
System.out.println(settings.getDarkMode()+ " " + settings.getFontSize());}}
```

```java
public class FirstPage {
    private Settings settings = Settings.getInstance();

    public void setAndPrintSettings() {
        settings.setDarkMode(true);
        settings.setFontSize(15);

        System.out.println(settings.getDarkMode()+ " " + settings.getFontSize());
    }
}
```
* 들여쓰기 파일은 구조가 한눈에 들어온다. (변수, 함수 등등..)  
* 반면, 들여쓰기를 하지 않는 코드는 열심히 분석하지 않는 이상 이해하기도 어렵다.   
* 하지만 때때로 간단한 제어문, 함수에서는 들여쓰기를 무시하고 싶은 경우도 있다.  
* **모든 맥락은 같아야 하는법 : 아무리 짧은 코드라도 들여쓰기를 제대로 해주는 습관을 들이자**    

```java
빈 while문이나 for문을 꼭! 사용해야할 때는 빈 블록을 잘 들여쓰고 괄호로 감싼다.
while (dis.read(buf, 0, readBufferSize) != -1)
;
```

# 팀 규칙        
> 프로그래머마다 각자 선호하는 규칙이 있지만 팀에 속한다면 선호해야할 규칙은 팀 규칙이다.      
       
팀은 한가지 규칙에 합의해야하고 모든 팀원은 그 규칙을 따라야 소프트웨어가 일관적인 스타일을 보인다.      
코딩 스타일을 의논하여(괄호를 어디에 넣을지, 네이밍은 어떻게 할지 등) IDE Formatter로 지정하여 구현하는 것이 옳은 방식이다.
좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄지고, 일기 쉬운 문서는 스타일은 일관적이고 매끄러워야 한다.   
한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 주어야한다.   
     
# 밥 아저씨의 형식 규칙 
> 사용하는 규칙은 간단하지만 코드 자체가 최고의 구현 표준 문서가 되는 것이다.   
    
```java
public class CodeAnalyzer implements JavaFileAnalysis { 
	private int lineCount;
	private int maxLineWidth;
	private int widestLineNumber;
	private LineWidthHistogram lineWidthHistogram; 
	private int totalChars;
	
	public CodeAnalyzer() {
		lineWidthHistogram = new LineWidthHistogram();
	}
	
	public static List<File> findJavaFiles(File parentDirectory) { 
		List<File> files = new ArrayList<File>(); 
		findJavaFiles(parentDirectory, files);
		return files;
	}
	
	private static void findJavaFiles(File parentDirectory, List<File> files) {
		for (File file : parentDirectory.listFiles()) {
			if (file.getName().endsWith(".java")) 
				files.add(file);
			else if (file.isDirectory()) 
				findJavaFiles(file, files);
		} 
	}
	
	public void analyzeFile(File javaFile) throws Exception { 
		BufferedReader br = new BufferedReader(new FileReader(javaFile)); 
		String line;
		while ((line = br.readLine()) != null)
			measureLine(line); 
	}
	
	private void measureLine(String line) { 
		lineCount++;
		int lineSize = line.length();
		totalChars += lineSize; 
		lineWidthHistogram.addLine(lineSize, lineCount);
		recordWidestLine(lineSize);
	}
	
	private void recordWidestLine(int lineSize) { 
		if (lineSize > maxLineWidth) {
			maxLineWidth = lineSize;
			widestLineNumber = lineCount; 
		}
	}

	public int getLineCount() { 
		return lineCount;
	}

	public int getMaxLineWidth() { 
		return maxLineWidth;
	}

	public int getWidestLineNumber() { 
		return widestLineNumber;
	}

	public LineWidthHistogram getLineWidthHistogram() {
		return lineWidthHistogram;
	}
	
	public double getMeanLineWidth() { 
		return (double)totalChars/lineCount;
	}

	public int getMedianLineWidth() {
		Integer[] sortedWidths = getSortedWidths(); 
		int cumulativeLineCount = 0;
		for (int width : sortedWidths) {
			cumulativeLineCount += lineCountForWidth(width); 
			if (cumulativeLineCount > lineCount/2)
				return width;
		}
		throw new Error("Cannot get here"); 
	}
	
	private int lineCountForWidth(int width) {
		return lineWidthHistogram.getLinesforWidth(width).size();
	}
	
	private Integer[] getSortedWidths() {
		Set<Integer> widths = lineWidthHistogram.getWidths(); 
		Integer[] sortedWidths = (widths.toArray(new Integer[0])); 
		Arrays.sort(sortedWidths);
		return sortedWidths;
	} 
}
```
