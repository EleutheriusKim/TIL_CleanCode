# 💡 현재 작성중....

# 들어가면서 
> 객체는 **처리의 추상화**다.     
> 스레드는 **일정의 추상화**다.         
         
**동시성(Concurrent)과 깔끔한 코드는 양립하기 어렵다.**            
단일 스레드에서 동작하는 코드를 작성하기는 쉽지만       
멀티 스레드로 코드를 작성하는 것은 문제를 발생시킬 가능성이 높기에 어렵다.      
         
이 장에서는       
* 여러 스레드를 동시에 돌리는 이유를 논한다.        
* 여러 스레드를 동시에 돌리는 어려움도 논한다.          
* 이런 어려움에 대처하고 깨끗한 코드를 작성하는 방법도 몇 가지 제안한다.     
* 마지막으로, 동시성 테스트하는 방법과 문제점을 논한다.        
   
# 동시성이 필요한 이유?   
동시성은 **결합을 없애는 전략**으로 **`무엇을 할 것`과 `언제 끝날 것`을 분리하는 전략**이다.        
    
**스레드가 하나인 프로그램은 `무엇`과 `언제` 가 서로 밀접하다.**                
그래서 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.            
예를 들면, 디버깅할 때 정지점을 정하고 어느 지점에 걸렸는지 파악할 수 있다.          
           
**`무엇`과 `언제`** 를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.             
프로그램은 거대한 루프 하나가 아닌, 작은 협력 프로그램 여럿으로 보여진다.              
그렇기에 시스템을 이해하기가 쉽고, 문제를 분리하기도 쉽다.         
        
예를 들면, 서블릿은 웹 혹은 EJB컨테이너 안에서 돌아가는데,      
이들 **컨테이너는 동시성을 부분적으로 관리한다.**        
         
1. 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다.        
2. 각 서블릿 스레드는 **다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.**       
         
이로인해, 서블릿 프로그래머는 들어오는 모든 웹 요청을 관리할 필요가 없다.   
       
**하지만, 동시성이 이렇게 간단한 문제라면 이 내용이 필요없다**            
실제로 웹 컨테이너가 제공하는 **`결합 분리 전략`** 은 완벽과 거리가 멀다.            
서블릿 프로그래머는 동시성을 정확히 구현하도록 각별한 주의와 노력을 기울여야 한다.      
그럼에도 서블릿 모델이 제공하는 구조적 이점은 아주 크다.         
         
하지만 구조적 개선만을 위해 동시성을 채택하는 건 아니다.                
어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피하다.           


   






   
   
